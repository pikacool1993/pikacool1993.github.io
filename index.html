<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="swift mvvm,">










<meta name="description" content="MVVM设计模式 实践（基于Swift）文件夹结构目录">
<meta name="keywords" content="swift mvvm">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift MVVM 实践">
<meta property="og:url" content="https://github.com/pikacool1993/2021/05/13/swift-mvvm/index.html">
<meta property="og:site_name" content="pikacool">
<meta property="og:description" content="MVVM设计模式 实践（基于Swift）文件夹结构目录">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://i.loli.net/2021/05/13/4kIza2MFXHgPOfm.png">
<meta property="og:updated_time" content="2021-05-13T10:32:11.085Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift MVVM 实践">
<meta name="twitter:description" content="MVVM设计模式 实践（基于Swift）文件夹结构目录">
<meta name="twitter:image" content="https://i.loli.net/2021/05/13/4kIza2MFXHgPOfm.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/pikacool1993/2021/05/13/swift-mvvm/">





  <title>pikacool</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">pikacool</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">也曾鲜衣怒马少年时，一夜忘尽长安花</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2022/07/14/unity-procedural-grid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/14/unity-procedural-grid/" itemprop="url">在Unity中创建程序网格</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-07-14T11:21:18+08:00">2022-07-14</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Procedural-Grid（程序网格）"><a href="#Procedural-Grid（程序网格）" class="headerlink" title="Procedural Grid（程序网格）"></a>Procedural Grid（程序网格）</h3><blockquote>
<p>原文 <a href="https://catlikecoding.com/unity/tutorials/procedural-grid/" target="_blank" rel="noopener">https://catlikecoding.com/unity/tutorials/procedural-grid/</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建点网格</span><br><span class="line">2.使用协程分析它们的位置</span><br><span class="line">3.使用三角形定义一个曲面</span><br><span class="line">4.自动生成法线</span><br><span class="line">5.添加纹理坐标和切线</span><br></pre></td></tr></table></figure>

<p>在本教程中，我们将创建一个简单的顶点和三角形网格</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/tutorial-image.jpg" alt="alt 图1"><br>复杂的外观之下是简单的几何形状</p>
<h4 id="渲染物体"><a href="#渲染物体" class="headerlink" title="渲染物体"></a>渲染物体</h4><p>如果你想在 Unity 中可视化某些东西，你可以使用网格。 它可能是从另一个程序导出的 3D 模型。 它可能是程序生成的网格。 它可以是精灵、UI 元素或粒子系统，Unity 也为此使用网格。 甚至屏幕效果也使用网格渲染。</p>
<p>那么什么是网格？ 从概念上讲，网格是图形硬件用来绘制复杂内容的构造。 它至少包含一组定义 3D 空间中的点的顶点，以及一组连接这些点的三角形（最基本的 2D 形状）。 三角形构成了网格所代表的任何表面。</p>
<p>由于三角形是平的并且有直边，它们可以用来完美地可视化平直的东西，比如立方体的面。 弯曲或圆形表面只能通过使用许多小三角形来近似。 如果三角形看起来足够小——不大于一个像素——那么你就不会注意到近似值。 通常这对于实时性能来说是不可行的，因此表面总是会出现某种程度的锯齿状。</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/01-shaded.png" alt="alt 图2-1"><br><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/01-wireframe.png" alt="alt 图2-2"><br>Unity 的默认胶囊体、立方体和球体，着色模式与线框模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何显示线框？</span><br><span class="line">您可以在其工具栏的左侧选择场景视图的显示模式。 前三个选项是着色、线框和着色线框。</span><br></pre></td></tr></table></figure>

<p>如果你想让一个游戏对象显示一个 3D 模型，它需要有两个组件。 第一种是 <code>Mesh Filter</code>，该组件包含对您希望显示的网格的引用。 第二个是<code>Mesh Render</code>，您可以使用它来配置网格的渲染方式。 应该使用哪种材质，是否应该投射或接收阴影，等等。</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/01-cube-object.png" alt="alt 图2-3"><br>Unity 的默认立方体游戏对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么会有一系列的材料？</span><br><span class="line">一个网格渲染器可以有多种材质。 这主要用于渲染具有多个独立三角形集的网格，称为子网格。 这些主要用于导入的 3D 模型，在本教程中不予介绍。</span><br></pre></td></tr></table></figure>

<p>您可以通过调整其材质来完全改变网格的外观。 Unity 的默认材质只是纯白色。 您可以通过 Assets / Create / Material 创建一个新的材质资源并将其拖到您的游戏对象上来替换它。 新材质默认使用 Unity 的标准着色器，它为您提供一组控件来调整表面的视觉行为方式。</p>
<p>向网格添加大量细节的快速方法是提供反照率贴图。 这是表示材料基本颜色的纹理。 当然，我们需要知道如何将此纹理投影到网格的三角形上。 这是通过将 2D 纹理坐标添加到顶点来完成的。 纹理空间的两个维度被称为 U 和 V，这就是为什么它们被称为 UV 坐标。 这些坐标通常位于 (0, 0) 和 (1, 1) 之间，覆盖整个纹理。 根据纹理设置，超出该范围的坐标会被固定或导致平铺。</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/01-uv-texture.png" alt="alt 图2-4"><br><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/01-material.png" alt="alt 图2-5"><br><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/01-textured.png" alt="alt 图2-6"><br>应用于 Unity 网格的 UV 测试纹理</p>
<h4 id="创建顶点网格"><a href="#创建顶点网格" class="headerlink" title="创建顶点网格"></a>创建顶点网格</h4><p>那么如何制作自己的网格呢？ 让我们通过生成一个简单的矩形网格来找出答案。 网格将由单位长度的方形瓷砖（四边形）组成。 创建一个新的 C# 脚本并将其转换为具有水平和垂直大小的网格组件。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Grid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> xSize, ySize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们将此组件添加到游戏对象时，我们还需要给它一个<code>Mesh Filter</code>和<code>Mesh Render</code>。 我们可以为我们的类添加一个属性，让 Unity 自动为我们添加它们。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Grid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> xSize, ySize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在您可以创建一个新的空游戏对象，将网格组件添加到其中，它还将具有其他两个组件。 设置渲染器的材质并保留过滤器的网格未定义。 我将网格的大小设置为 10 x 5。</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/02-grid.png" alt="alt 图3-1"><br>Grid物件</p>
<p>一旦对象<code>Awake</code>，我们就会生成实际的网格，这发生在我们进入播放模式时。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Generate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们首先关注顶点位置，然后将三角形留到后面。 我们需要保存一个 3D 向量数组来存储这些点。 顶点的数量取决于网格的大小。 我们需要在每个四边形的拐角处有一个顶点，但相邻的四边形可以共享同一个顶点。 因此，我们需要比每个维度中的图块多一个顶点。</p>
<p><code>(#x+1)(#y+1)</code></p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/02-grid-indices.png" alt="alt 图3-2"><br>4 x 2 网格的顶点和四边形索引</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Vector3[] vertices;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Generate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vertices = <span class="keyword">new</span> Vector3[(xSize + <span class="number">1</span>) * (ySize + <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们可视化这些顶点，以便我们可以检查我们是否正确定位它们。 我们可以通过添加一个 <code>OnDrawGizmos</code> 方法并在场景视图中为每个顶点绘制一个小的黑色球体来做到这一点。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmos</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Gizmos.color = Color.black;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices.Length; i++) &#123;</span><br><span class="line">        Gizmos.DrawSphere(vertices[i], <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么是 gizmos?</span><br><span class="line">Gizmos 是可以在编辑器中使用的视觉提示。 默认情况下，它们在场景视图中可见，而在游戏视图中不可见，但您可以通过它们的工具栏进行调整。 Gizmos 实用程序类允许您绘制图标、线条和其他一些东西。</span><br><span class="line">Gizmos 可以在 OnDrawGizmos 方法中绘制，该方法由 Unity 编辑器自动调用。 另一种方法是 OnDrawGizmosSelected，它只对选定对象调用。</span><br></pre></td></tr></table></figure>

<p>当我们不处于播放模式时，这将产生错误，因为当 Unity 处于编辑模式时，当我们没有任何顶点时，也会调用 OnDrawGizmos 方法。 为防止出现此错误，请检查数组是否存在，如果不存在则跳出方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmos</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vertices == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/02-gizmo.png" alt="alt 图3-3"><br>Gizmos</p>
<p>在播放模式下，我们只能在原点看到一个球体。 这是因为我们还没有定位顶点，所以它们都在那个位置重叠。 我们必须使用双循环遍历所有位置。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Generate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vertices = <span class="keyword">new</span> Vector3[(xSize + <span class="number">1</span>) * (ySize + <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, y = <span class="number">0</span>; y &lt;= ySize; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= xSize; x++, i++) &#123;</span><br><span class="line">            vertices[i] = <span class="keyword">new</span> Vector3(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么Gizmos不随物体移动？</span><br><span class="line">Gizmo 直接在世界空间中绘制，而不是在对象的本地空间中。 如果您希望它们尊重您的对象变换，则必须通过使用 transform.TransformPoint(vertices[i]) 而不仅仅是 vertices[i] 来显式应用它。</span><br></pre></td></tr></table></figure>

<p>我们现在看到了顶点，但是它们的放置顺序是不可见的。 我们可以使用颜色来显示这一点，但我们也可以通过使用协程来减慢这个过程。 这就是我在脚本中使用 <code>System.Collections</code> 的原因。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StartCoroutine(Generate());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Vector3[] vertices;</span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Generate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WaitForSeconds wait = <span class="keyword">new</span> WaitForSeconds(<span class="number">0.05f</span>);</span><br><span class="line">    vertices = <span class="keyword">new</span> Vector3[(xSize + <span class="number">1</span>) * (ySize + <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, y = <span class="number">0</span>; y &lt;= ySize; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= xSize; x++, i++) &#123;</span><br><span class="line">            vertices[i] = <span class="keyword">new</span> Vector3(x, y);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> wait;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建网格"><a href="#创建网格" class="headerlink" title="创建网格"></a>创建网格</h4><p>现在我们知道顶点的位置正确，我们可以处理实际的网格。 除了在我们自己的组件中保存对它的引用之外，我们还必须将它分配给 <code>Mesh Filter</code> 。 然后，一旦我们处理了顶点，我们就可以将它们提供给我们的网格。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Mesh mesh;</span><br><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Generate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WaitForSeconds wait = <span class="keyword">new</span> WaitForSeconds(<span class="number">0.05f</span>);</span><br><span class="line"></span><br><span class="line">    GetComponent&lt;MeshFilter&gt;().mesh = mesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">    mesh.name = <span class="string">"Procedural Grid"</span>;</span><br><span class="line"></span><br><span class="line">    vertices = <span class="keyword">new</span> Vector3[(xSize + <span class="number">1</span>) * (ySize + <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, y = <span class="number">0</span>; y &lt;= ySize; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= xSize; x++, i++) &#123;</span><br><span class="line">            vertices[i] = <span class="keyword">new</span> Vector3(x, y);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> wait;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mesh.vertices = vertices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们的组件是否需要抓住网格？</span><br><span class="line">我们只需要在 Generate 方法中引用网格。 由于 Mesh Filter 也有它的参考，它无论如何都会留下来。 我将其设为全局变量，因为本教程之外的下一个合乎逻辑的步骤是为网格设置动画，我鼓励您尝试。</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/03-mesh.png" alt="alt 图4-1"><br>在Play模式下</p>
<p>我们现在有一个网格处于播放模式，但它还没有出现，因为我们没有给它任何三角形。 三角形是通过顶点索引数组定义的。 由于每个三角形都有三个点，因此三个连续的索引描述了一个三角形。 让我们从一个三角形开始。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Generate</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    triangles[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    triangles[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    triangles[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    mesh.triangles = triangles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在有一个三角形，但是我们使用的三个点都在一条直线上。 这会产生一个不可见的退化三角形。 前两个顶点很好，但是我们应该跳到下一行的第一个顶点。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">triangles[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">triangles[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">triangles[<span class="number">2</span>] = xSize + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这确实给了我们一个三角形，但它只能从一个方向看到。 在这种情况下，它仅在从 Z 轴的相反方向看时可见。 因此，您可能需要旋转视图才能看到它。</p>
<p>三角形从哪一侧可见取决于其顶点索引的方向。 默认情况下，如果它们以顺时针方向排列，则三角形被认为是向前且可见的。 逆时针三角形被丢弃，因此我们不需要花时间渲染对象的内部，这些对象通常无论如何都不会被看到。</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/03-triangle-sides.png" alt="alt 图4-2"><br>三角形的两条边</p>
<p>所以当我们向下看 Z 轴时，要让三角形出现，我们必须改变它的顶点遍历的顺序。 我们可以通过交换最后两个索引来做到这一点。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">triangles[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">triangles[<span class="number">1</span>] = xSize + <span class="number">1</span>;</span><br><span class="line">triangles[<span class="number">2</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/03-first-triangle.png" alt="alt 图4-3"><br>第一个三角形</p>
<p>我们现在有一个三角形覆盖了我们网格的第一个图块的一半。 为了覆盖整个瓷砖，我们只需要第二个三角形。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">triangles[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">triangles[<span class="number">1</span>] = xSize + <span class="number">1</span>;</span><br><span class="line">triangles[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">triangles[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">triangles[<span class="number">4</span>] = xSize + <span class="number">1</span>;</span><br><span class="line">triangles[<span class="number">5</span>] = xSize + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/03-quad.png" alt="alt 图4-4"><br>由两个三角形组成的四边形</p>
<p>由于这些三角形共享两个顶点，我们可以将其减少到四行代码，明确地只提到每个顶点索引一次。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">triangles[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">triangles[<span class="number">3</span>] = triangles[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">triangles[<span class="number">4</span>] = triangles[<span class="number">1</span>] = xSize + <span class="number">1</span>;</span><br><span class="line">triangles[<span class="number">5</span>] = xSize + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/03-first-quad.png" alt="alt 图4-5"><br>第一个四边形</p>
<p>我们可以通过把它变成一个循环来创建整个第一行图块。 当我们迭代顶点和三角形索引时，我们必须跟踪两者。 让我们也将 yield 语句移动到这个循环中，这样我们就不再需要等待顶点出现了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[xSize * <span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ti = <span class="number">0</span>, vi = <span class="number">0</span>, x = <span class="number">0</span>; x &lt; xSize; x++, ti += <span class="number">6</span>, vi++) &#123;</span><br><span class="line">    triangles[ti] = vi;</span><br><span class="line">    triangles[ti + <span class="number">3</span>] = triangles[ti + <span class="number">2</span>] = vi + <span class="number">1</span>;</span><br><span class="line">    triangles[ti + <span class="number">4</span>] = triangles[ti + <span class="number">1</span>] = vi + xSize + <span class="number">1</span>;</span><br><span class="line">    triangles[ti + <span class="number">5</span>] = vi + xSize + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> wait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顶点 Gizmo 现在立即出现，并且在短暂的等待后，所有三角形都立即出现。 要看到瓦片一张一张地出现，我们必须在每次迭代时更新网格，而不是仅在循环之后更新。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mesh.triangles = triangles;</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> wait;</span><br></pre></td></tr></table></figure>

<p>现在通过将单循环变成双循环来填充整个网格。 请注意，移动到下一行需要将顶点索引增加一个，因为每行的顶点数比图块多一个。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[xSize * ySize * <span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ti = <span class="number">0</span>, vi = <span class="number">0</span>, y = <span class="number">0</span>; y &lt; ySize; y++, vi++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; xSize; x++, ti += <span class="number">6</span>, vi++) &#123;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/03-full-grid.png" alt="alt 图4-5"></p>
<p>如您所见，整个网格现在都充满了三角形，一次一行。 一旦您对此感到满意，您可以删除所有协程代码，以便立即创建网格。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    Generate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Generate</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    GetComponent&lt;MeshFilter&gt;().mesh = mesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">    mesh.name = <span class="string">"Procedural Grid"</span>;</span><br><span class="line"></span><br><span class="line">    vertices = <span class="keyword">new</span> Vector3[(xSize + <span class="number">1</span>) * (ySize + <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, y = <span class="number">0</span>; y &lt;= ySize; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= xSize; x++, i++) &#123;</span><br><span class="line">            vertices[i] = <span class="keyword">new</span> Vector3(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mesh.vertices = vertices;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] triangles = <span class="keyword">new</span> <span class="keyword">int</span>[xSize * ySize * <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ti = <span class="number">0</span>, vi = <span class="number">0</span>, y = <span class="number">0</span>; y &lt; ySize; y++, vi++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; xSize; x++, ti += <span class="number">6</span>, vi++) &#123;</span><br><span class="line">            triangles[ti] = vi;</span><br><span class="line">            triangles[ti + <span class="number">3</span>] = triangles[ti + <span class="number">2</span>] = vi + <span class="number">1</span>;</span><br><span class="line">            triangles[ti + <span class="number">4</span>] = triangles[ti + <span class="number">1</span>] = vi + xSize + <span class="number">1</span>;</span><br><span class="line">            triangles[ti + <span class="number">5</span>] = vi + xSize + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mesh.triangles = triangles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么不使用单个四边形？</span><br><span class="line">当我们创建一个平面矩形表面时，我们只需要两个三角形就足够了。 这是绝对正确的。 更复杂的结构的关键在于它允许更多的控制和表达。 实验！</span><br></pre></td></tr></table></figure>

<h4 id="生成附加顶点数据"><a href="#生成附加顶点数据" class="headerlink" title="生成附加顶点数据"></a>生成附加顶点数据</h4><p>我们的网格目前以一种特殊的方式点亮。 那是因为我们还没有给网格提供任何法线。 默认的法线方向是 (0, 0, 1)，这与我们需要的完全相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">法线是如何工作的？</span><br><span class="line">法线是垂直于表面的向量。 我们总是使用单位长度的法线，它们指向表面的外部，而不是内部。</span><br><span class="line"></span><br><span class="line">法线可用于确定光线照射到表面的角度（如果有的话）。 具体如何使用取决于着色器。</span><br><span class="line"></span><br><span class="line">由于三角形总是平坦的，因此不需要提供有关法线的单独信息。 但是，这样做我们可以作弊。 实际上顶点没有法线，三角形有。 通过将自定义法线附加到顶点并在它们之间跨三角形进行插值，我们可以假装我们有一个平滑弯曲的表面，而不是一堆平坦的三角形。 这种错觉是令人信服的，只要你不注意网格的尖锐轮廓。</span><br></pre></td></tr></table></figure>

<p>法线是每个顶点定义的，所以我们必须填充另一个向量数组。 或者，我们可以要求网格根据其三角形来计算法线本身。 这次让我们偷懒吧。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Generate</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    …</span><br><span class="line">    mesh.triangles = triangles;</span><br><span class="line">    mesh.RecalculateNormals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如何重新计算法线？</span><br><span class="line">Mesh.RecalculateNormals 方法计算每个顶点的法线，方法是确定哪些三角形与该顶点连接，确定这些平面三角形的法线，对它们进行平均，并对结果进行归一化。</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-no-normals.png" alt="alt 图5-1"><br><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-normals.png" alt="alt 图5-2"><br>没有法线和有法线的区别</p>
<p>接下来是UV坐标。 您可能已经注意到网格当前具有统一的颜色，即使它使用具有反照率纹理的材质。 这是有道理的，因为如果我们自己不提供 UV 坐标，那么它们都为零。</p>
<p>要使纹理适合我们的整个网格，只需将顶点的位置除以网格尺寸即可。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vertices = <span class="keyword">new</span> Vector3[(xSize + <span class="number">1</span>) * (ySize + <span class="number">1</span>)];</span><br><span class="line">Vector2[] uv = <span class="keyword">new</span> Vector2[vertices.Length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, y = <span class="number">0</span>; y &lt;= ySize; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= xSize; x++, i++) &#123;</span><br><span class="line">        vertices[i] = <span class="keyword">new</span> Vector3(x, y);</span><br><span class="line">        uv[i] = <span class="keyword">new</span> Vector2(x / xSize, y / ySize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mesh.vertices = vertices;</span><br><span class="line">mesh.uv = uv;</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-uv-wrong-clamp.png" alt="alt 图5-3"><br><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-uv-wrong-wrap.png" alt="alt 图5-4"><br>不正确的 UV 坐标、夹紧与包裹纹理</p>
<p>纹理现在出现了，但它没有覆盖整个网格。 它的确切外观取决于纹理的环绕模式是否设置为钳制或重复。 发生这种情况是因为我们目前正在将整数除以整数，这会产生另一个整数。 为了在整个网格中获得零和一之间的正确坐标，我们必须确保我们使用的是浮点数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv[i] = <span class="keyword">new</span> Vector2((<span class="keyword">float</span>)x / xSize, (<span class="keyword">float</span>)y / ySize);</span><br></pre></td></tr></table></figure>

<p>纹理现在投影到整个网格上。 当我将网格的大小设置为 10 x 5 时，纹理将显示为水平拉伸。 这可以通过调整材质的纹理平铺设置来解决。 通过将其设置为 (2, 1)，U 坐标将加倍。 如果纹理设置为重复，那么我们将看到它的两个方形图块。</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-tiling.png" alt="alt 图5-5"><br><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-uv-correct-1-1.png" alt="alt 图5-6"><br><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-uv-correct-2-1.png" alt="alt 图5-7"><br>正确的 UV 坐标，平铺 1,1 与 2,1</p>
<p>向表面添加更明显细节的另一种方法是使用法线贴图。 这些贴图包含编码为颜色的法线向量。 将它们应用于表面将产生比单独使用顶点法线创建的更详细的灯光效果。</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-normal-map.png" alt="alt 图5-8"><br><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-material.png" alt="alt 图5-9"><br>凹凸不平的表面，采用金属制成，具有戏剧性的效果</p>
<p>将此材料应用于我们的网格会产生凹凸，但它们是不正确的。 我们需要将切线向量添加到我们的网格中以正确定位它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">切线如何工作？</span><br><span class="line">法线贴图在切线空间中定义。 这是一个围绕物体表面流动的 3D 空间。 这种方法允许我们在不同的位置和方向应用相同的法线贴图。</span><br><span class="line"></span><br><span class="line">表面法线在这个空间中代表向上，但是哪种方式是正确的呢？ 这是由切线定义的。 理想情况下，这两个向量之间的夹角为 90°。 它们的叉积产生定义 3D 空间所需的第三方向。 实际上，该角度通常不是 90°，但结果仍然足够好。</span><br><span class="line"></span><br><span class="line">所以切线是 3D 向量，但 Unity 实际上使用的是 4D 向量。 它的第四个分量始终为 -1 或 1，用于控制第三个切线空间维度的方向——向前或向后。 这有助于法线贴图的镜像，这通常用于具有双边对称性的事物的 3D 模型，例如人。 Unity 的着色器执行此计算的方式要求我们使用 -1。</span><br></pre></td></tr></table></figure>

<p>由于我们有一个平面，所有切线都指向同一个方向，即向右。</p>
<p><img src="https://catlikecoding.com/unity/tutorials/procedural-grid/04-normal-mapped.png" alt="alt 图5-10"><br>假装凹凸不平的平坦表面</p>
<p>现在您知道如何创建简单的网格并使用材质使其看起来更复杂。 网格需要顶点位置和三角形，通常也是 UV 坐标 - 最多四组 - 通常也需要切线。 您也可以添加顶点颜色，尽管 Unity 的标准着色器不使用这些颜色。 您可以创建自己的着色器来使用这些颜色，但这是另一个教程的内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2022/01/05/unity-shader-mathfunc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/05/unity-shader-mathfunc/" itemprop="url">Unity Shader常用函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-05T10:06:36+08:00">2022-01-05</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Unity-Shader常用函数"><a href="#Unity-Shader常用函数" class="headerlink" title="Unity Shader常用函数"></a>Unity Shader常用函数</h1><h2 id="CG标准函数库"><a href="#CG标准函数库" class="headerlink" title="CG标准函数库"></a>CG标准函数库</h2><h3 id="Unity坐标转换"><a href="#Unity坐标转换" class="headerlink" title="Unity坐标转换"></a>Unity坐标转换</h3><ul>
<li><code>transform.localToWorldMatrix</code> 本地坐标转世界坐标的矩阵</li>
<li><code>transform.worldToLocalMatrix</code> 世界坐标转本地坐标的矩阵</li>
<li>Unity Shader中 左乘 <code>_World2Object</code> 矩阵来实现世界坐标转本地坐标变换</li>
<li>Unity Shader中 左乘 <code>_Object2World</code> 矩阵来实现本地坐标转世界坐标变换</li>
<li><code>UNITY_MATRIX_MV</code> 基本变换矩阵 × 摄像机变换矩阵</li>
<li><code>UNITY_MATRIX_MVP</code> 基本变换矩阵 × 摄像机变换矩阵 × 投影变换矩阵</li>
<li><code>UNITY_MATRIX_V</code> 摄像机变换矩阵</li>
<li><code>UNITY_MATRIX_P</code> 投影变换矩阵</li>
<li><code>UNITY_MATRIX_VP</code> 摄像机变换矩阵 × 投影变换矩阵</li>
<li><code>UNITY_MATRIX_T_MV</code> （基本变换矩阵 × 摄像机变换矩阵）的转置矩阵</li>
<li><code>UNITY_MATRIX_IT_MV</code> （基本变换矩阵 × 摄像机变换矩阵）的逆转置矩阵</li>
<li><code>UNITY_MATRIX_TEXTURE0</code> 纹理变换矩阵</li>
</ul>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>数学函数用于执行数学上常用计算，包括三角函数、幂函数、圆函数、向量和矩阵操作函数，这些函数都被重载，以支持标量数据和不同长度的向量作为输入参数</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="red">abs(x)</font></td>
<td align="center"><font color="red">返回输入参数的绝对值</font></td>
</tr>
<tr>
<td align="center">acos(x)</td>
<td align="center">反余切函数，输入参数范围为[-1, 1]， 返回[0, π]区间的角度值</td>
</tr>
<tr>
<td align="center">all(x)</td>
<td align="center">如果输入参数均不为0，则返回<code>true</code>，否则返回<code>false</code>。与运算</td>
</tr>
<tr>
<td align="center">any(x)</td>
<td align="center">输入参数只要有其中一个不为0，则返回<code>true</code>。 或运算</td>
</tr>
<tr>
<td align="center">asin(x)</td>
<td align="center">反正弦函数，输入参数范围为[-1, 1]，返回[-π/2, π/2]区间的角度值</td>
</tr>
<tr>
<td align="center">atan(x)</td>
<td align="center">反正切函数，返回角度值范围为[-π/2, π/2]</td>
</tr>
<tr>
<td align="center">atan2(y, x)</td>
<td align="center">计算 y/x 的反正切值。实际上和 atan(x) 函数功能完全一样，只是输入参数不同。atan(x) = atan2(x, float(1))</td>
</tr>
<tr>
<td align="center"><font color="red">ceil(x)</font></td>
<td align="center"><font color="red">对输入参数向上取整。例如：ceil(float(1.3))，其返回值为2.0</font></td>
</tr>
<tr>
<td align="center"><font color="red">clamp(x, a, b)</font></td>
<td align="center"><font color="red">如果 x 值小于 a ，返回 a ； 如果 x 值大于 b ，返回 b ；否则返回 x</font></td>
</tr>
<tr>
<td align="center">cos(x)</td>
<td align="center">返回弧度 x 的余弦值。返回值范围为 [-1, 1]</td>
</tr>
<tr>
<td align="center">cosh(x)</td>
<td align="center">双曲余弦函数，计算 x 的双曲余弦值</td>
</tr>
<tr>
<td align="center"><font color="red">cross(A, B)</font></td>
<td align="center"><font color="red">返回两个三元向量的叉积。注意，输入参数必须是三元向量</font></td>
</tr>
<tr>
<td align="center">degrees(x)</td>
<td align="center">输入参数为弧度值（radians）, 函数将其转换为角度值（degrees）</td>
</tr>
<tr>
<td align="center">determinant(m)</td>
<td align="center">计算矩阵的行列式因子</td>
</tr>
<tr>
<td align="center"><font color="red">dot(A, B)</font></td>
<td align="center"><font color="red">计算 A 和 B 的点积。参数 A 和 B 可以是标量，也可以是向量（输入参数方面，点积和叉积函数有很大的不同）</font></td>
</tr>
<tr>
<td align="center">exp(x)</td>
<td align="center">计算 e^x 的值，e = 2.71828182845904523536</td>
</tr>
<tr>
<td align="center">exp2(x)</td>
<td align="center">计算 2^x 的值</td>
</tr>
<tr>
<td align="center"><font color="red">floor(x)</font></td>
<td align="center"><font color="red">对输入参数向下取整。例如：floor(float(1.3)) 返回的值为1.0；但是 floor(float(-1.3)) 返回的值为-2.0</font></td>
</tr>
<tr>
<td align="center">fmod(x, y)</td>
<td align="center">返回 x/y 的余数。如果 y 为0，结果不可预料</td>
</tr>
<tr>
<td align="center">frexp(x, out exp)</td>
<td align="center">将浮点数 x 分解为尾数和指数，即 x = m * 2^exp， 返回m，并将指数存入exp中；如果 x 为 0，则尾数和指数都返回0</td>
</tr>
<tr>
<td align="center"><font color="red">frac(x)</font></td>
<td align="center"><font color="red">向下取整</font></td>
</tr>
<tr>
<td align="center">isfinite(x)</td>
<td align="center">判断标量或者向量中的每个数据是否是有限数，如果是返回<code>true</code>；否则返回<code>false</code>；无限的或者非数据（not-a-number NaN）</td>
</tr>
<tr>
<td align="center">isinf(x)</td>
<td align="center">判断标量或者向量中的每个数据是否是无限数，如果是返回<code>true</code>；否则返回<code>false</code></td>
</tr>
<tr>
<td align="center">isnan(x)</td>
<td align="center">判断标量或者向量中的每个数据是否是非数据（not-a-number NaN），如果是返回<code>true</code>；否则返回<code>false</code></td>
</tr>
<tr>
<td align="center">ldexp(x, n)</td>
<td align="center">计算 x*2^n 的值</td>
</tr>
<tr>
<td align="center"><font color="red">lerp(a, b, f)</font></td>
<td align="center"><font color="red">计算(1 - f) * a + b * f 或者 a + f * (b - a) 的值。即在下限 a 和上限 b 之间进行插值，f 表示权值。注意：如果 a 和 b 是向量，则权值 f 必须是标量或者等长的向量</font></td>
</tr>
<tr>
<td align="center">lit(NdotL, NdotH, m)</td>
<td align="center">N 表示法向量；L 表示入射光向量；H 表示半角向量；m 表示高光系数。 函数计算环境光、散射光、镜面光的贡献，返回的 4 元向量：X 位表示环境光的贡献，总是 1.0。 Y 位代表散射光的贡献，如果 N • L &lt; 0 ，则为 0；否则为 N • L。Z 位代表镜面光的贡献，如果 N • L &lt; 0 或者 N • H &lt; 0，则为 0；否则为 (N • H) ^ m。 W 位始终为 1.0</td>
</tr>
<tr>
<td align="center">log(x)</td>
<td align="center">计算 ln(x) 的值，x 必须大于0</td>
</tr>
<tr>
<td align="center">log2(x)</td>
<td align="center">计算 log2(x) 的值，x 必须大于0 （函数返回一个数字以2为底的对数）</td>
</tr>
<tr>
<td align="center">log10(x)</td>
<td align="center">计算 log10(x) 的值，x 必须大于 0 （函数返回一个数字以10为底的对数）</td>
</tr>
<tr>
<td align="center">max(a, b)</td>
<td align="center">比较两个标量或等长向量元素，返回大值</td>
</tr>
<tr>
<td align="center">min(a, b)</td>
<td align="center">比较两个标量或等长向量元素，返回小值</td>
</tr>
<tr>
<td align="center"><font color="red">pow(x, y)</font></td>
<td align="center"><font color="red">x 的 y 次方</font></td>
</tr>
<tr>
<td align="center">round(x)</td>
<td align="center">离 x 最近的整数</td>
</tr>
<tr>
<td align="center">modf(x, out lp)</td>
<td align="center">将值 x 分成小数部分和整数部分</td>
</tr>
<tr>
<td align="center"><font color="red">mul(M, N)</font></td>
<td align="center"><font color="red">计算两个矩阵相乘，如果 M 为 AxB 阶矩阵， N 为 BxC 阶矩阵，则返回 AxC 阶矩阵。下面两个函数为其重载函数。</font></td>
</tr>
<tr>
<td align="center">mul(M, v)</td>
<td align="center">计算矩阵和向量相乘</td>
</tr>
<tr>
<td align="center">mul(v, M)</td>
<td align="center">计算向量和矩阵相乘</td>
</tr>
<tr>
<td align="center">noise(x)</td>
<td align="center">噪声函数，返回值始终在[0, 1]之间；对于同样的输入，始终返回相同的值（也就是说，并不是真正意义上的随机噪声）。</td>
</tr>
<tr>
<td align="center">radians(x)</td>
<td align="center">函数将角度值转换为弧度值</td>
</tr>
<tr>
<td align="center">rsqrt(x)</td>
<td align="center">x 的反平方根，x 必须大于0</td>
</tr>
<tr>
<td align="center"><font color="red">saturate(x)</font></td>
<td align="center"><font color="red">如果 x 小于0，返回0；如果 x 大于1，返回1；否则返回 x</font></td>
</tr>
<tr>
<td align="center"><font color="red">sign(x)</font></td>
<td align="center"><font color="red">如果 x 大于0，返回1；如果 x 小于0，返回 0；否则返回 0</font></td>
</tr>
<tr>
<td align="center">sin(x)</td>
<td align="center">输入参数为弧度，计算正弦值，返回值范围为[-1, 1]</td>
</tr>
<tr>
<td align="center">sincos(float x, out s, out c)</td>
<td align="center">该函数是同时计算 x 的 sin 值和 cos 值，其中 s=sin(x)，c=cos(x)。该函数用于“同时需要计算 sin 值和 cos 值的情况”，比分别运算要快很多!</td>
</tr>
<tr>
<td align="center">sinh(x)</td>
<td align="center">计算双曲正弦值</td>
</tr>
<tr>
<td align="center"><font color="red">smoothstep(min, max, x)</font></td>
<td align="center"><font color="red">值 x 位于 min、max 区间中。如果 x = min，返回0；如果 x = max，返回1；如果 x 在两者之间，按照下列公式返回数据：<code>float smoothstep(float min, float max, float x) { x = clamp((x - min)/(max - min), 0.0, 1.0); }</code>    </font></td>
</tr>
<tr>
<td align="center"><font color="red">step(a, x)</font></td>
<td align="center"><font color="red">如果 x &lt; a，返回0；否则返回1</font></td>
</tr>
<tr>
<td align="center">sqrt(x)</td>
<td align="center">求 x 的平方根，x 必须大于0</td>
</tr>
<tr>
<td align="center">tan(x)</td>
<td align="center">输入参数为弧度，计算正切值</td>
</tr>
<tr>
<td align="center">tanh(x)</td>
<td align="center">计算双曲正切值</td>
</tr>
<tr>
<td align="center">transpose(M)</td>
<td align="center">M 为矩阵，计算其转置矩阵</td>
</tr>
</tbody></table>
<h3 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h3><p>CG语言标准函数库中有3个几何函数会经常被使用到，分别是：</p>
<ul>
<li><code>normalize</code>，对向量进行归一化</li>
<li><code>reflect</code>，计算反射关方向向量</li>
<li><code>refract</code>，计算折射光方向向量</li>
</ul>
<p>注意：</p>
<ul>
<li>着色程序中的向量最好进行归一化之后再使用，否则会出现难以预料的错误</li>
<li><code>reflect</code> 函数和 <code>refract</code> 函数都存在以“入射光方向向量”作为参数，注意这两个函数中使用的入射光方向向量是从外指向几何顶点的；平时我们在着色程序中或者在课本上都是将入射光方向向量作为从顶点发出</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tex1D(sampler1D tex, float s)</td>
<td align="center">一维纹理查询</td>
</tr>
<tr>
<td align="center">tex1D(sampler1D tex, float s, float dsdx, float dsdy)</td>
<td align="center">使用导数值（derivatives）查询一维纹理</td>
</tr>
<tr>
<td align="center">tex1D(sampler1D tex, float2 sz)</td>
<td align="center">一维纹理查询，并进行深度值比较</td>
</tr>
<tr>
<td align="center">tex1D(sampler1D tex, float2 sz, float dsdx, float dsdy)</td>
<td align="center">使用导数值（derivatives）查询一维纹理，并进行深度值比较</td>
</tr>
<tr>
<td align="center">tex1Dproj(sampler1D tex，float2 sq)</td>
<td align="center">一维投影纹理查询</td>
</tr>
<tr>
<td align="center">tex1Dproj(sampler1D tex，float3 szq)</td>
<td align="center">一维投影纹理查询，并比较深度值</td>
</tr>
<tr>
<td align="center"><font color="red">tex2D(sampler2D tex, float2 sq)</font></td>
<td align="center"><font color="red">二维纹理查询</font></td>
</tr>
<tr>
<td align="center">tex2D(sampler2D tex, float2 s, float2 dsdx, float2 dsdy)</td>
<td align="center">使用导数值（derivatives）查询二维纹理</td>
</tr>
<tr>
<td align="center">tex2D(sampler2D tex, float3 sz)</td>
<td align="center">二维纹理查询，并进行深度值比较</td>
</tr>
<tr>
<td align="center">tex2D(sampler2D tex, float3 sz, float2 dsdx, float2 dsdy)</td>
<td align="center">使用导数值（derivatives）查询二维纹理，并进行深度值比较</td>
</tr>
<tr>
<td align="center"><font color="red">tex2Dproj(sampler2D tex, float3 sq)</font></td>
<td align="center"><font color="red">二维投影纹理查询</font></td>
</tr>
<tr>
<td align="center">tex2Dproj(sampler2D tex，float4 szq)</td>
<td align="center">二维投影纹理查询，并比较深度值</td>
</tr>
<tr>
<td align="center">texRECT(samplerRECT tex, float2 s)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">texRECT(samplerRECT tex, float2 s, float2 dsdx, float2 dsdy)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">texRECT(samplerRECT tex, float3 sz)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">texRECT(samplerRECT tex, float3 sz, float2 dsdx, float2 dsdy)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">texRECTproj(samplerRECT tex，float3 sq)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">texRECTproj(samplerRECT tex，float4 szq)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">tex3D(sampler3D tex, float3 s)</td>
<td align="center">三维纹理查询</td>
</tr>
<tr>
<td align="center">tex3D(sampler3D tex, float3 s, float3 dsdx, float3 dsdy)</td>
<td align="center">结合导数值（derivatives）查询三维纹理</td>
</tr>
<tr>
<td align="center">tex3Dproj(sampler3D tex，float4 szq)</td>
<td align="center">三维投影纹理查询，并比较深度值</td>
</tr>
<tr>
<td align="center"><font color="red">texCUBE(samplerCUBE tex，float3 s)</font></td>
<td align="center"><font color="red">查询立方体纹理</font></td>
</tr>
<tr>
<td align="center">texCUBE(samplerCUBE tex, float3 s, float3 dsdx, float3 dsdy)</td>
<td align="center">结合导数值（derivatives）查询立方体纹理</td>
</tr>
<tr>
<td align="center">texCUBE(samplerCUBE tex，float4 sq)</td>
<td align="center">立方体投影纹理查询</td>
</tr>
</tbody></table>
<p>s 象征一元、二元和三元纹理坐标<br><br>z 代表使用深度比较的值<br><br>q 表示一个透视值（其实就是透视投影后所得到的的齐次坐标的后一位），这个值被用来除以纹理坐标（S），得到新的纹理坐标（已归一化到0和1之间）然后用于纹理查询</p>
<p>纹理函数非常多，总的来说，按照纹理数进行分类，即1D纹理函数、2D纹理函数、3D纹理函数以及立方体纹理函数。需要注意，<code>texRECT</code> 函数查询的纹理实际上也是二维纹理。3D纹理，另一个比较学术化的名称是“体纹理”，体纹理通常用于体绘制，体纹理用于记录空间中的体细节数据。</p>
<p>还有一类比较特殊的纹理查询函数以 <code>proj</code> 结尾，主要针对投影纹理进行查询。所谓投影纹理是指：将纹理当做一张幻灯片投影到场景中，使用投影纹理技术需要计算投影纹理坐标，然后使用投影纹理坐标进行查询，使用投影纹理坐标进行查询的函数就是投影纹理查询函数。本质来说，投影纹理查询函数和普通的纹理查询函数没什么不同，唯一区别在于“投影纹理查询函数使用计算得到的投影纹理坐标，并在使用之前会将该投影纹理坐标除以透视值”。</p>
<p>🌰：计算得到的投影纹理坐标为<code>float4 uvproj</code>, 使用二维投影纹理查询函数：<code>tex2Dproj(texture, uvproj)</code>;<br><br>等价于按如下方式使用普通二维纹理查询函数：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 uvproj = uvproj/uvproj.q;</span><br><span class="line">tex2D(texture, uvproj);</span><br></pre></td></tr></table></figure>

<h3 id="偏导函数"><a href="#偏导函数" class="headerlink" title="偏导函数"></a>偏导函数</h3><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ddx(a)</td>
<td align="center">参数a对应一个像素位置，返回该像素值在X轴上的偏导数</td>
</tr>
<tr>
<td align="center">ddy(a)</td>
<td align="center">参数a对应一个像素位置，返回该像素值在Y轴上的偏导数</td>
</tr>
</tbody></table>
<ul>
<li>函数 <code>ddx</code> 和 <code>ddy</code> 用于求取相邻像素间某属性的差值；</li>
<li>函数 <code>ddx</code> 和 <code>ddy</code> 的输入参数通常是纹理坐标；</li>
<li>函数 <code>ddx</code> 和 <code>ddy</code> 返回相邻像素间的属性差值；</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="旋转公式"><a href="#旋转公式" class="headerlink" title="旋转公式"></a>旋转公式</h4><ul>
<li><p>顺时针旋转：<code>x = x * cos(α) - y*cos(α)</code>, <code>y = x * sin(α) + y * cos(α)</code></p>
</li>
<li><p>逆时针旋转：<code>x = x * cos(α) + y*cos(α)</code>, <code>y = x * sin(α) - y * cos(α)</code></p>
</li>
</ul>
<h4 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h4><p><code>UnityObjectToClipPos(v.vertex) == mul(UNITY_MATRIX_MVP, v.vertex)</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2021/05/13/swift-mvvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/13/swift-mvvm/" itemprop="url">Swift MVVM 实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-13T18:20:33+08:00">2021-05-13</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MVVM设计模式-实践（基于Swift）"><a href="#MVVM设计模式-实践（基于Swift）" class="headerlink" title="MVVM设计模式 实践（基于Swift）"></a>MVVM设计模式 实践（基于Swift）</h3><h4 id="文件夹结构目录"><a href="#文件夹结构目录" class="headerlink" title="文件夹结构目录"></a>文件夹结构目录</h4><p><img src="https://i.loli.net/2021/05/13/4kIza2MFXHgPOfm.png" alt="mvvm_files.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2021/02/23/unity-ios-plugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/23/unity-ios-plugin/" itemprop="url">Unity iOS 插件实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-23T10:37:22+08:00">2021-02-23</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Unity-和-Objective-C-交互"><a href="#Unity-和-Objective-C-交互" class="headerlink" title="Unity 和 Objective-C 交互"></a>Unity 和 Objective-C 交互</h3><h4 id="Unity-调用-iOS-原生方法"><a href="#Unity-调用-iOS-原生方法" class="headerlink" title="Unity 调用 iOS 原生方法"></a>Unity 调用 iOS 原生方法</h4><p>在 <code>iOS</code> 中，<code>C</code> 语言可以和 <code>Objective-C</code> 语言进行混合编译的，<code>C#</code> 语言又提供了一种调用 <code>C</code>（非 <code>C++</code>）语言的机制， 这样就可以实现 <code>C#</code> 调用 <code>Objective-C</code> 的功能</p>
<h5 id="IL2CPP"><a href="#IL2CPP" class="headerlink" title="IL2CPP"></a>IL2CPP</h5><blockquote>
<p>What is IL2CPP?<br>The technology that we refer to as IL2CPP has two distinct parts.<br>1. An ahead-of-time (AOT) compiler<br>2. A runtime library to support the virtual machine<br>The AOT compiler translates Intermediate Language (IL), the low-level output from .NET compilers, to C++ source code. The runtime library provides services and abstractions like a garbage collector, platform-independent access to threads and files, and implementations of internal calls (native code which modifies managed data structures directly).</p>
</blockquote>
<p><img src="https://blogs.unity3d.com/wp-content/uploads/2015/04/il2cpp-toolchain-smaller.png" alt="LayoutEngine.png"></p>
<p>Unity脚本编译成中间语言（<code>IL</code>，动态库等），通过IL2CPP程序将 <code>IL</code> 转换成 <code>C++</code>语言</p>
<h5 id="DllImport"><a href="#DllImport" class="headerlink" title="DllImport"></a>DllImport</h5><p><code>C#</code> 提供了 <code>DllImport</code> 机制来实现 <code>C#</code> 于 <code>C</code> 语言的方法调用</p>
<ul>
<li>无参无返回值</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">CallFunction</span>(<span class="params"></span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>有参无返回值</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">CallFunction</span>(<span class="params"><span class="keyword">string</span> param</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>有参有返回值</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">string</span> <span class="title">CallFunction</span>(<span class="params"><span class="keyword">string</span> param</span>)</span>;</span><br></pre></td></tr></table></figure>

<h6 id="DllImport-的语法规则"><a href="#DllImport-的语法规则" class="headerlink" title="DllImport 的语法规则"></a>DllImport 的语法规则</h6><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">extern</span> ReturnValue <span class="title">FunctionName</span>(<span class="params"><span class="keyword">string</span> parameter1, <span class="keyword">int</span> parameter2</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>由于是 <code>C</code> 语言，支持的参数及其数据类型是非常有限的，诸如 <code>int</code>、<code>float</code>、<code>double</code>、<code>char</code> 等这类两种语言中都存在的基础数据类型，是可以实现直接映射的，但是 <code>C#</code> 中的 <code>string</code> 对应到 <code>C</code> 中，就是 <code>char*</code> 了</p>
<h6 id="iOS-实现-DllImport"><a href="#iOS-实现-DllImport" class="headerlink" title="iOS 实现 DllImport"></a>iOS 实现 DllImport</h6><p><code>.h</code> 文件中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="keyword">char</span>* CallFunction(<span class="keyword">char</span> *parma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.mm</code> 文件中</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* CallFunction(<span class="keyword">char</span> *parma) &#123;</span><br><span class="line">	<span class="comment">// return ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="iOS-调用-Unity-原生方法"><a href="#iOS-调用-Unity-原生方法" class="headerlink" title="iOS 调用 Unity 原生方法"></a>iOS 调用 Unity 原生方法</h6><p>这种方式用于 <code>iOS</code> 给 <code>Unity</code> 一些方法回调</p>
<ul>
<li><code>MonoPInvokeCallback</code></li>
</ul>
<blockquote>
<p>Attribute used to annotate functions that will be called back from the unmanaged world.</p>
</blockquote>
<p>举个栗子🌰，比如我们现在需要使用手机相册权限拿一张图片在 <code>Unity</code> 中使用</p>
<p><code>C#</code> 中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 Unity 中接收回调的事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> UnityAction&lt;<span class="keyword">string</span>&gt; _selectPhotoAction;</span><br><span class="line"><span class="comment">// 声明回调代理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">SelectPhotoCallback</span>(<span class="params"><span class="keyword">string</span> photo</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个初始化方法中设置回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_SetSelectPhotoCallback(DidReceiveSelectPhotoCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 供 Unity 中调用选择照片的方法，并传入一个选择结果的回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSelectPhoto</span>(<span class="params">UnityAction&lt;<span class="keyword">string</span>&gt; callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_selectPhotoAction = callback;</span><br><span class="line">	_SelectPhoto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 原生的回调</span></span><br><span class="line">[<span class="meta">AOT.MonoPInvokeCallback(typeof(SelectPhotoCallback))</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DidReceiveSelectPhotoCallback</span>(<span class="params"><span class="keyword">string</span> photo</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_selectPhotoAction?.Invoke(photo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 Unity 中定义的接收原生事件回调传给 OC</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> _SetupSelectPhotoCallback(SelectPhotoCallback callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 OC 原生方法</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">"__Internal"</span>)</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="keyword">void</span> _SelectPhoto();</span><br></pre></td></tr></table></figure>

<p><code>OC</code> 中</p>
<p><code>.h</code> 文件中：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NativeUtils</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(*SelectPhotoCallback)(<span class="keyword">const</span> <span class="keyword">char</span> *photo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> _SetupSelectPhotoCallback(SelectPhotoCallback callback);</span><br><span class="line">    <span class="keyword">void</span> _SelectPhoto();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><code>.mm</code> 文件中：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define Convert2Char( _x_ ) ( _x_ != NULL &amp;&amp; [_x_ isKindOfClass:[NSString class]] ) ? strdup( [_x_ UTF8String] ) : strdup( [@<span class="meta-string">""</span> UTF8String] )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NativeUtils</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SelectPhotoCallback selectPhotoCallback;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WMNativeUtils</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> NativeUtils *instance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken,^&#123;</span><br><span class="line">        instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)bindSelectPhotoCallback:(SelectPhotoCallback)callback &#123;</span><br><span class="line">    <span class="keyword">self</span>.selectPhotoCallback = callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)selectPhoto &#123;</span><br><span class="line">	<span class="comment">// 调起系统相册，选择...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark UIImagePickerControllerDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIImagePickerControllerInfoKey</span>,<span class="keyword">id</span>&gt; *)info &#123;</span><br><span class="line">    [picker dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">UIImage</span> *image = info[<span class="built_in">UIImagePickerControllerEditedImage</span>];</span><br><span class="line">    <span class="comment">// base64 形式</span></span><br><span class="line">    <span class="built_in">NSString</span> *imageBase64String = [imageData base64EncodedStringWithOptions:<span class="built_in">NSDataBase64EncodingEndLineWithLineFeed</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.selectPhotoCallback) &#123;</span><br><span class="line">        <span class="keyword">self</span>.selectPhotoCallback(Convert2Char(imageBase64String));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - CPlusPlus</span></span><br><span class="line"><span class="keyword">void</span> _SetupSelectPhotoCallback(SelectPhotoCallback callback) &#123;</span><br><span class="line">    [[NativeUtils shared] bindSelectPhotoCallback:callback];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _SelectPhoto() &#123;</span><br><span class="line">    [[NativeUtils shared] selectPhoto];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2021/02/22/objc-interface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/22/objc-interface/" itemprop="url">Objective-C中的@interface和@implementation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-22T17:09:33+08:00">2021-02-22</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Objective-C中的-interface和-implementation"><a href="#Objective-C中的-interface和-implementation" class="headerlink" title="Objective-C中的@interface和@implementation"></a>Objective-C中的@interface和@implementation</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Objc的类声明使用 <code>interface</code> ，但是在其它面向对象的语言中使用 <code>class</code> 来表示，<code>interface</code> 在 Java 中近似于 Objc 中的 <code>protocol</code>, 所以 Objc 中的 <code>interface</code> 以及 <code>implementation</code> 的设计思想是什么呢？</p>
<h4 id="interface"><a href="#interface" class="headerlink" title="@interface"></a>@interface</h4><p>引用一段官方的解释</p>
<blockquote>
<p>This information goes into the interface for your class—it defines the way you intend other objects to interact with instances of your class. The public interface is described separately from the internal behavior of your class, which makes up the class implementation. In Objective-C, the interface and implementation are usually placed in separate files so that you only need to make the interface public. </p>
</blockquote>
<p>大概意思就是它定义了你希望与其它对象和类实例进行交互的方式，也就是 <code>interface</code> 只存在于能相互影响的两者间</p>
<h4 id="那么问题来了-interface-生成了-class"><a href="#那么问题来了-interface-生成了-class" class="headerlink" title="那么问题来了 @interface 生成了 class?"></a>那么问题来了 <code>@interface</code> 生成了 <code>class</code>?</h4><p>刚接触 Objc 时肯定是从怎么写一个类开始的，在 <code>.h</code> 文件中写 <code>@interface</code> 声明类，然后在 <code>.m</code> 文件中写 <code>@implementation</code>，所以自然就会觉得是 <code>@interface</code> 就相当于 java 或者 C# 中写一个 <code>class</code></p>
<p>Talk is cheap. Show me the code</p>
<p>在 <code>Dog</code> 类中只有 <code>.m</code> 文件只写 <code>@implementation</code>，在 <code>Cat</code> 类中只有 <code>.h</code> 文件只写 <code>@interface</code></p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Cat</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class dogClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"Dog"</span>);</span><br><span class="line">Class catClass = <span class="built_in">NSClassFromString</span>(<span class="string">@"Cat"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Dog: %@"</span>, dogClass);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Cat: %@"</span>, catClass);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Dog: Dog</span><br><span class="line">$ Cat: (null)</span><br></pre></td></tr></table></figure>

<p>这个结果说明是 <code>@implementation</code> 生成了 <code>class</code></p>
<h4 id="interface和-implementation"><a href="#interface和-implementation" class="headerlink" title="@interface和@implementation"></a>@interface和@implementation</h4><p><code>@interface</code> 对类结构的合成没有决定性的作用， 只是没有它会丢失一些类自身的原始数据，如属性列表和协议列表，对对象消息发送并没有影响，所以 <code>@interface</code> 就是为了给调用者看，暴露自己的公有方法和属性等，是一个升级版的 <code>protocol</code></p>
<h4 id="interface和-protocol"><a href="#interface和-protocol" class="headerlink" title="@interface和@protocol"></a>@interface和@protocol</h4><p><code>@interface</code> 和 <code>@protocal</code> 间唯一的区别就是是否和一个类型绑定</p>
<p>比如我们常常定义一个代理 <code>id&lt;XXDelegate&gt; delegate</code> 我们就不用知道这个代理到底是什么类型的，只用知道它能干什么就好了，同样可以这样定义 <code>XXDelegate *delegate</code>, 这样就会耦合一个 <code>XXDelegate</code> 类型，我们并不需要关心它是什么</p>
<h4 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h4><p>当子类需要使用父类的一个私有属性（方法）时，需要把这个属性（方法）放到父类的header中，但暴露给子类的同时暴露给了外部调用者，如何解决?</p>
<p>建立一个私有header，使用类扩展定义父类需要暴露给子类的属性（方法），然后在各自的 <code>.m</code> 文件中引用，如：</p>
<p>有 <code>Father</code> 类和 <code>Son</code> 类，继承关系，可以考虑建一个如 <code>FatherPrivate.h</code> 的私有header：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FatherPrivate.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *privateThingSonNeed;</span><br><span class="line">- (<span class="keyword">void</span>)privateMethodNeedsSonOverride;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>同时在 <code>Father.m</code> 和 <code>Son.m</code> 中同时 <code>import</code> 这个私有header，这样 <code>Father</code> 和 <code>Son</code> 内部对于定义的属性和方法都是透明的，而对外部是隐藏的（因为两个类的header中都没有 <code>import</code> 这个私有header）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2021/02/07/layoutengine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/07/layoutengine/" itemprop="url">Auto Layout</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-02-07T10:06:58+08:00">2021-02-07</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Auto-Layout-的生命周期"><a href="#Auto-Layout-的生命周期" class="headerlink" title="Auto Layout 的生命周期"></a>Auto Layout 的生命周期</h3><h4 id="包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。"><a href="#包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。" class="headerlink" title="包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。"></a>包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。</h4><ul>
<li>布局引擎系统叫作 Layout Engine ，是 Auto Layout 的核心，主导着整个界面布局。</li>
</ul>
<p><img src="https://i.loli.net/2021/02/07/EPQoJCiapdD6TG5.png" alt="LayoutEngine.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2020/06/19/xcode-instruments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/19/xcode-instruments/" itemprop="url">App 方法耗时检查工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-19T11:20:42+08:00">2020-06-19</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul>
<li>定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时</li>
</ul>
<h3 id="定时器设计"><a href="#定时器设计" class="headerlink" title="定时器设计"></a>定时器设计</h3><p><img src="https://s2.loli.net/2022/07/14/M97KuaXJDGEcCxN.png" alt="D4211C5F-44CF-42D8-81B6-5CE97220ADF9.png"></p>
<h3 id="获取方法调用堆栈"><a href="#获取方法调用堆栈" class="headerlink" title="获取方法调用堆栈"></a>获取方法调用堆栈</h3><p>callstackSymbols 是一种获取方法调用栈的方法，但是只能获取当前线程的调用栈，为了把对主线程的影响降到最小，获取当前线程调用栈的工作就需要在其他线程去做。所以，这个解题思路就需要换成：使用系统提供的 task_threads 去获取所有线程，使用 thread_info 得到各个线程的详细信息，使用 thread_get_state 方法去获取线程栈里的所有栈指针</p>
<p>如果接下来立刻进行符号化去获取方法名，那么就需要去 __LINKEDIT segment 里查找栈指针地址所对应符号表的符号，特别当你设置的时间隔较小的时候，符号化过程会持续消耗较多的 CPU 资源，从而影响主线程。</p>
<p>所以，获取到栈指针后，我们可以不用立刻做符号化，而是先使用一个结构体将栈地址记录下来，最后再统一符号化，将对主线程的影响降到最低，这样获取的数据也会更加准确。</p>
<h3 id="设计记录栈地址的结构体"><a href="#设计记录栈地址的结构体" class="headerlink" title="设计记录栈地址的结构体"></a>设计记录栈地址的结构体</h3><p><img src="https://s2.loli.net/2022/07/14/YOfXNp32lZVmK5B.png" alt="C728D3BE-925F-4816-855A-845E22A5C1A0.png"></p>
<p>previous 记录的是上一个栈指针的地址</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2020/03/02/csharp-base-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/02/csharp-base-code/" itemprop="url">Unity3D 实用小技巧 - C# 常用基础代码汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-02T10:40:59+08:00">2020-03-02</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Unity3D-实用小技巧-C-常用基础代码汇总"><a href="#Unity3D-实用小技巧-C-常用基础代码汇总" class="headerlink" title="Unity3D 实用小技巧 - C# 常用基础代码汇总"></a>Unity3D 实用小技巧 - C# 常用基础代码汇总</h2><h3 id="DateTime"><a href="#DateTime" class="headerlink" title="DateTime"></a>DateTime</h3><p>DateTime 数字类型，DateTime 是一个包含日期、时间的类型，此类型通过 ToString() 转换为字符串时，可根据传入给 Tostring() 的参数转换为多种字符串格式。</p>
<p><code>System.DateTime currentTime=new System.DateTime();</code></p>
<ul>
<li><p>取当前年月日时分秒：<br><code>currentTime=System.DateTime.Now;</code></p>
</li>
<li><p>取当前年：<code>int 年=currentTime.Year;</code></p>
</li>
<li><p>取当前月：<code>int 月=currentTime.Month;</code></p>
</li>
<li><p>取当前日：<code>int 日=currentTime.Day;</code></p>
</li>
<li><p>取当前时：<code>int 时=currentTime.Hour;</code></p>
</li>
<li><p>取当前分：<code>int 分=currentTime.Minute;</code></p>
</li>
<li><p>取当前秒：<code>int 秒=currentTime.Second;</code></p>
</li>
<li><p>取当前毫秒：<br><code>int 毫秒=currentTime.Millisecond;（变量可用中文）</code></p>
</li>
<li><p>取中文日期显示-年月日时分：<br><code>string strY=currentTime.ToString(&quot;f&quot;); //不显示秒</code></p>
</li>
<li><p>取中文日期显示-年月：<br><code>string strYM=currentTime.ToString(&quot;y&quot;);</code></p>
</li>
<li><p>取中文日期显示-月日：<br><code>string strMD=currentTime.ToString(&quot;m&quot;);</code></p>
</li>
<li><p>取中文年月日：<br><code>string strYMD=currentTime.ToString(&quot;D&quot;);</code></p>
</li>
<li><p>取当前时分，格式为：(14：24)：<br><code>string strT=currentTime.ToString(&quot;t&quot;);</code></p>
</li>
<li><p>取当前时间，格式为：2003-09-23T14:46:48：<br><code>string strT=currentTime.ToString(&quot;s&quot;);</code></p>
</li>
<li><p>取当前时间，格式为：2003-09-2314:48:30Z：<br><code>string strT=currentTime.ToString(&quot;u&quot;);</code></p>
</li>
<li><p>取当前时间，格式为：2003-09-2314:48：<br><code>string strT=currentTime.ToString(&quot;g&quot;);</code></p>
</li>
<li><p>取当前时间，格式为：Tue,23 Sep 2003 14:52:40 GMT：<br><code>string strT=currentTime.ToString(&quot;r&quot;);</code></p>
</li>
<li><p>获得当前时间n 天后的日期时间：<br><code>DateTime newDay = DateTime.Now.AddDays(100);</code></p>
</li>
</ul>
<h3 id="其他类型字符串转换-变量-ToString"><a href="#其他类型字符串转换-变量-ToString" class="headerlink" title="其他类型字符串转换  变量.ToString()"></a>其他类型字符串转换  变量.ToString()</h3><pre><code>12345.ToString(&quot;n&quot;); //生成 12,345.00

12345.ToString(&quot;C&quot;); //生成 ￥12,345.00

12345.ToString(&quot;e&quot;);//生成 1.234500e+004

12345.ToString(&quot;f4&quot;); //生成 12345.0000

12345.ToString(&quot;x&quot;); //生成 3039 (16进制)

12345.ToString(&quot;p&quot;); //生成 1,234,500.00%</code></pre><h3 id="字符型转换转为-32-位数字型"><a href="#字符型转换转为-32-位数字型" class="headerlink" title="字符型转换转为 32 位数字型"></a>字符型转换转为 32 位数字型</h3><pre><code>Int32.Parse(变量) Int32.Parse(&quot;常量&quot;)
Int32.Parse(&quot;123&quot;);//生成 123</code></pre><h3 id="变量-Length-数字型"><a href="#变量-Length-数字型" class="headerlink" title="变量.Length 数字型"></a>变量.Length 数字型</h3><pre><code>取字串长度：如：string str=&quot;中国&quot;
int Len = str.Length ; //Len是自定义变量， str是求测的字串的变量名</code></pre><h3 id="System-Text-Encoding-Default-GetBytes-变量-：字码转换转为比特码"><a href="#System-Text-Encoding-Default-GetBytes-变量-：字码转换转为比特码" class="headerlink" title="System.Text.Encoding.Default.GetBytes(变量)：字码转换转为比特码"></a>System.Text.Encoding.Default.GetBytes(变量)：字码转换转为比特码</h3><pre><code>byte[]bytStr = System.Text.Encoding.Default.GetBytes(str);
然后可得到比特长度：len = bytStr.Length;</code></pre><h3 id="System-Text-StringBuilder-“”-字符串相加，（-号是不是也一样？）"><a href="#System-Text-StringBuilder-“”-字符串相加，（-号是不是也一样？）" class="headerlink" title="System.Text.StringBuilder(“”)- 字符串相加，（+号是不是也一样？）"></a>System.Text.StringBuilder(“”)- 字符串相加，（+号是不是也一样？）</h3><pre><code>System.Text.StringBuilder sb = new System.Text.StringBuilder(&quot;&quot;);
sb.Append(&quot;中华&quot;);
sb.Append(&quot;人民&quot;);
sb.Append(&quot;共和国&quot;);</code></pre><h3 id="变量-Substring-参数1-参数2-：截取字串的一部分，参数1为左起始位数，参数2为截取几位。"><a href="#变量-Substring-参数1-参数2-：截取字串的一部分，参数1为左起始位数，参数2为截取几位。" class="headerlink" title="变量.Substring(参数1,参数2)：截取字串的一部分，参数1为左起始位数，参数2为截取几位。"></a>变量.Substring(参数1,参数2)：截取字串的一部分，参数1为左起始位数，参数2为截取几位。</h3><pre><code>strings1 = str.Substring(0,2);</code></pre><h3 id="char-IsWhiteSpce-字串变量，位数-——逻辑型：查指定位置是否空字符"><a href="#char-IsWhiteSpce-字串变量，位数-——逻辑型：查指定位置是否空字符" class="headerlink" title="char.IsWhiteSpce(字串变量，位数)——逻辑型：查指定位置是否空字符"></a>char.IsWhiteSpce(字串变量，位数)——逻辑型：查指定位置是否空字符</h3><pre><code>string str=&quot;你好 AnimeKing&quot;;
char.IsWhiteSpace(str,2); //结果为：True, 第一个字符是0位，2是第三个字符。</code></pre><h3 id="char-IsPunctuation-‘字符’-——逻辑型：查字符是否是标点符号"><a href="#char-IsPunctuation-‘字符’-——逻辑型：查字符是否是标点符号" class="headerlink" title="char.IsPunctuation(‘字符’) ——逻辑型：查字符是否是标点符号"></a>char.IsPunctuation(‘字符’) ——逻辑型：查字符是否是标点符号</h3><pre><code>char.IsPunctuation(&apos;A&apos;);//返回：False</code></pre><h3 id="int-’字符’-：把字符转为数字，查代码点，注意是单引号"><a href="#int-’字符’-：把字符转为数字，查代码点，注意是单引号" class="headerlink" title="(int)’字符’ ：把字符转为数字，查代码点，注意是单引号"></a>(int)’字符’ ：把字符转为数字，查代码点，注意是单引号</h3><pre><code>(int)&apos;A&apos;; //结果为A字的代码：20013</code></pre><h3 id="char-代码-：把数字转为字符，查代码代表的字符"><a href="#char-代码-：把数字转为字符，查代码代表的字符" class="headerlink" title="(char)代码 ：把数字转为字符，查代码代表的字符"></a>(char)代码 ：把数字转为字符，查代码代表的字符</h3><pre><code>(char)22269; //返回“国”字。</code></pre><h3 id="清除字串前后空格："><a href="#清除字串前后空格：" class="headerlink" title="清除字串前后空格："></a>清除字串前后空格：</h3><pre><code>变量.Trim()</code></pre><h3 id="字串替换-：字串变量-Replace-“子字串”-”替换为”"><a href="#字串替换-：字串变量-Replace-“子字串”-”替换为”" class="headerlink" title="字串替换 ：字串变量.Replace(“子字串”,”替换为”)"></a>字串替换 ：字串变量.Replace(“子字串”,”替换为”)</h3><pre><code>string str=&quot;中国&quot;;
str=str.Replace(&quot;国&quot;,&quot;央&quot;); //将国字换为央字
Response.Write(str); //输出结果为“中央”</code></pre><h3 id="字串对比一般都用-if-str1-str2-，并且也有别的方法"><a href="#字串对比一般都用-if-str1-str2-，并且也有别的方法" class="headerlink" title="字串对比一般都用: if(str1==str2){ }  ，并且也有别的方法"></a>字串对比一般都用: if(str1==str2){ }  ，并且也有别的方法</h3><pre><code>(1)  string str1; str2
//语法:str1.EndsWith(str2); __检测字串str1是否以字串str2结尾,返回布尔值.如：    if(str1.EndsWith(str2)){ Response.Write(&quot;字串str1是以&quot;+str2+&quot;结束的&quot;); }
(2) //语法:str1.Equals(str2);__检测字串str1是否与字串str2相等,返回布尔值,用法同上
(3) //语法Equals(str1,str2); __检测字串str1是否与字串str2相等,返回布尔值,用法同上</code></pre><h3 id="IndexOf-、LastIndexOf-：查找字串中指定字符或字串首次（最后一次）出现的位置，返回索引值"><a href="#IndexOf-、LastIndexOf-：查找字串中指定字符或字串首次（最后一次）出现的位置，返回索引值" class="headerlink" title="IndexOf()、LastIndexOf()：查找字串中指定字符或字串首次（最后一次）出现的位置，返回索引值"></a>IndexOf()、LastIndexOf()：查找字串中指定字符或字串首次（最后一次）出现的位置，返回索引值</h3><pre><code>str1.IndexOf(&quot;字&quot;)；//查找“字”在str1中的索引值（位置）
str1.IndexOf(&quot;字串&quot;)；//查找“字串”的第一个字符在str1中的索引值（位置）
str1.IndexOf(&quot;字串&quot;,3,2)；//从str1第4个字符起，查找2个字符，查找“字串”的第一个字符在str1中的索引值（位置）</code></pre><h3 id="Insert-在字串中指定索引位插入指定字符"><a href="#Insert-在字串中指定索引位插入指定字符" class="headerlink" title="Insert()在字串中指定索引位插入指定字符"></a>Insert()在字串中指定索引位插入指定字符</h3><pre><code>str1.Insert(1,&quot;字&quot;);在str1的第二个字符处插入“字”，如果str1=&quot;中国&quot;，插入后为“中字国”；</code></pre><h3 id="PadLeft-、PadRight-：在字串左（或右）加空格或指定char字符，使字串达到指定长度"><a href="#PadLeft-、PadRight-：在字串左（或右）加空格或指定char字符，使字串达到指定长度" class="headerlink" title="PadLeft()、PadRight() ：在字串左（或右）加空格或指定char字符，使字串达到指定长度"></a>PadLeft()、PadRight() ：在字串左（或右）加空格或指定char字符，使字串达到指定长度</h3><pre><code>string str1=&quot;中国人&quot;;
str1=str1.PadLeft(10,&apos;1&apos;); //无第二参数为加空格 ,结果为“1111111中国人” ， 字串长为10</code></pre><h3 id="Remove-：从指定位置开始删除指定数的字符"><a href="#Remove-：从指定位置开始删除指定数的字符" class="headerlink" title="Remove()：从指定位置开始删除指定数的字符"></a>Remove()：从指定位置开始删除指定数的字符</h3><pre><code>string str1=&quot;我是萨达姆的崇拜者之一&quot;;
str1.Remove(5,4); //结果为“我是萨达姆之一”</code></pre><h3 id="判断是否存在文件夹，没有则创建"><a href="#判断是否存在文件夹，没有则创建" class="headerlink" title="判断是否存在文件夹，没有则创建"></a>判断是否存在文件夹，没有则创建</h3><pre><code>if (Directory.Exists(url) == false)
{
    Directory.CreateDirectory(url);
}</code></pre><h3 id="方法中的参数，返回值"><a href="#方法中的参数，返回值" class="headerlink" title="方法中的参数，返回值"></a>方法中的参数，返回值</h3><p>ref 型参数：该种类型的参数传递变量地址给方法（引用传递），传递前变量必须初始化。该类型与out型的区别在于：</p>
<ul>
<li>ref 型传递变量前，变量必须初始化，否则编译器会报错, 而 out 型则不需要初始化。</li>
<li>ref 型传递变量，数值可以传入方法中，而 out 型无法将数据传入方法中。换而言之，ref 型有进有出，out 型只出不进。</li>
</ul>
<p>out 型参数：与 ref 型类似，仅用于传回结果。</p>
<p>注意：</p>
<ul>
<li><p>out 型数据在方法中必须要赋值，否则编译器会报错。</p>
<p>  如:如下若将代码中的 sum 1 方法的方法体</p>
<p>  改为 a+=b ; 则编译器会报错。原因：out 型只出不进，在没给 a 赋值前是不能使用的</p>
<p>  改为 b+=b+2 ; 编译器也会报错。原因：out 型数据在方法中必须要赋值。</p>
</li>
<li><p>重载方法时若两个方法的区别仅限于一个参数类型为 ref 另一个方法中为 out ，编译器会报错</p>
<p>  如：若将下面的代码中将方法名 vsum1 改为 sum（或者将方法名 sum 改为 sum1），编译器会报错。</p>
<p>  Error 1 Cannot define overloaded method ‘sum’ because it differs from another method only on ref and out</p>
<p>  原因：参数类型区别仅限于 为 ref 与为 out 时，若重载对编译器而言两者的元数据表示完全相同。</p>
<pre><code>classC
{
    //1. in型参数
    publicvoidsum(int a, int b) {
        a += b;
    }
    //2. ref型参数
    publicvoidsum(refint a, int b)
    {
        a += b;
    }
    //3. out型参数
    publicvoidsum1(outint a, int b)
    {
        a = b+2;
    }
    publicstaticvoidMain(string[] args)
    {
        C c = new C();
        int a = 1, b = 2;
        c.sum(a,b);
        Console.WriteLine(&quot;a:{0}&quot;, a);
        a = 1; b = 2;
        c.sum(ref a, b);
        Console.WriteLine(&quot;ref a:{0}&quot;, a);
        a = 1; b = 2;
        c.sum1(out a, b);
        Console.WriteLine(&quot;out a:{0}&quot;, a);
    }
}</code></pre></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2019/07/25/swift-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/25/swift-learn/" itemprop="url">Swift5.0边学边记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-25T22:35:37+08:00">2019-07-25</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Swift5-0边学边记"><a href="#Swift5-0边学边记" class="headerlink" title="Swift5.0边学边记"></a>Swift5.0边学边记</h1><h2 id="swiftc"><a href="#swiftc" class="headerlink" title="swiftc"></a>swiftc</h2><ul>
<li><p>存放路径</p>
<pre><code>Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</code></pre></li>
<li><p>操作</p>
<p>  生成语法树</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swiftc -dump-ast main.swift</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>生成最简洁的SIL代码

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc -emit-sil main.swift</span><br></pre></td></tr></table></figure>


生成LLVM IR代码

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swiftc -emit-ir main.swift</span><br></pre></td></tr></table></figure>


生成汇编代码

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swiftc -emit-assembly main.swift -o main.s</span><br></pre></td></tr></table></figure></code></pre><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="AT-amp-T"><a href="#AT-amp-T" class="headerlink" title="AT&amp;T"></a>AT&amp;T</h4><ul>
<li><p>16个常用寄存器</p>
<p>  <code>rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp</code><br>  <code>r8, r9, r10, r11, r12, r13, r14, r15</code></p>
</li>
<li><p>寄存器具体用途</p>
<p>  rax, rdx常作为函数返回值使用</p>
<p>  rdi, rsi, rdx, rcx, r8, r9等寄存器常用于存放函数参数</p>
<p>  rsp, rbp用于栈操作</p>
<p>  rip作为指令指针，存放着CPU下一条要执行的指令地址，一旦CPU读取一条指令，rip会自动指向下一条指令</p>
</li>
</ul>
<h4 id="ARM64"><a href="#ARM64" class="headerlink" title="ARM64"></a>ARM64</h4><h6 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h6><ul>
<li><p>ARM64 有34个寄存器，包括31个通用寄存器、SP、PC、CPSR</p>
<table>
<thead>
<tr>
<th align="center">寄存器</th>
<th align="center">位数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x0-x30</td>
<td align="center">64bit</td>
<td align="center">通用寄存器，如果有需要可以当做32bit使用：wO-w30</td>
</tr>
<tr>
<td align="center">FP(x29)</td>
<td align="center">64bit</td>
<td align="center">保存栈帧地址(栈底指针)</td>
</tr>
<tr>
<td align="center">LR(x30)</td>
<td align="center">64bit</td>
<td align="center">通常称X30为程序链接寄存器，保存子程序结束后需要执行的下一条指令</td>
</tr>
<tr>
<td align="center">SP</td>
<td align="center">64bit</td>
<td align="center">保存栈指针,使用 SP/WSP 来进行对 SP 寄存器的访问</td>
</tr>
<tr>
<td align="center">PC</td>
<td align="center">64bit</td>
<td align="center">程序计数器，俗称PC指针，总是指向即将要执行的下一条指令,在arm64中，软件是不能改写PC寄存器的</td>
</tr>
<tr>
<td align="center">CPSR</td>
<td align="center">64bit</td>
<td align="center">状态寄存器</td>
</tr>
</tbody></table>
</li>
<li><p>用途</p>
<p>  x0 - x7: 用于子程序调用时的参数传递，x0还用于返回值传递，当使用 r0 - r30 访问时，它就是一个64位的数。当使用 w0 - w30 访问时，访问的是这些寄存器的低32位</p>
</li>
<li><p>指令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MOV    X1，X0         ;将寄存器X0的值传送到寄存器X1</span><br><span class="line">ADD    X0，X1，X2     ;寄存器X1和X2的值相加后传送到X0</span><br><span class="line">SUB    X0，X1，X2     ;寄存器X1和X2的值相减后传送到X0</span><br><span class="line">AND    X0，X0，#0xF    ; X0的值与0xF相位与后的值传送到X0</span><br><span class="line">ORR    X0，X0，#9      ; X0的值与9相位或后的值传送到X0</span><br><span class="line">EOR    X0，X0，#0xF    ; X0的值与0xF相异或后的值传送到X0</span><br><span class="line">LDR    X5，[X6，#0x08]        ；X6寄存器加0x08的和的地址值内的数据传送到X5</span><br><span class="line">STR X0, [SP, #0x8]         ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间</span><br><span class="line">STP  x29, x30, [sp, #0x10]    ;入栈指令</span><br><span class="line">LDP  x29, x30, [sp, #0x10]    ;出栈指令</span><br><span class="line">CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）</span><br><span class="line">CBNZ ;比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）</span><br><span class="line">CMP  ;比较指令，相当于SUBS，影响程序状态寄存器CPSR </span><br><span class="line">B/BL  ;绝对跳转#imm， 返回地址保存到LR（X30）</span><br><span class="line">RET   ;子程序返回指令，返回地址默认保存在LR（X30）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="lldb常用指令"><a href="#lldb常用指令" class="headerlink" title="lldb常用指令"></a>lldb常用指令</h3><ul>
<li><p>读取寄存器的值</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ register read/格式</span><br><span class="line">exp:</span><br><span class="line">$ register read/x</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改寄存器的值</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ register write 寄存器名称 数值</span><br><span class="line">exp:</span><br><span class="line">$ register write rax 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取内存中的值</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ x/数量-格式-字节大小 内存地址</span><br><span class="line">exp:</span><br><span class="line">$ x/3xw 0x0000010</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改内存中的值</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ memory write 内存地址 数值</span><br><span class="line">exp:</span><br><span class="line">$ memory write 0x0000010 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x 是16进制</span><br><span class="line">f 是浮点</span><br><span class="line">d 是十进制</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节大小</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b - byte 1字节</span><br><span class="line">h - half word 2字节</span><br><span class="line">w - word 4字节</span><br><span class="line">g - giant word 8字节</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>规律</p>
<p>  内存地址格式为： 0x4bdc(%rip), 一般是全局变量， 全局区（数据段）</p>
<p>  内存地址格式为： -0x78(%rbp), 一般是局部变量，栈空间</p>
<p>  内存地址格式为： 0x10(%rax), 一般是堆空间</p>
</li>
<li><p>查看调用栈</p>
<p>  <code>bt</code></p>
</li>
</ul>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li><p>双重可选</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num : Int?? = nil</span><br><span class="line">print(num ?? 10)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>输出结果：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional(10)  // 为什么还会输出一个可选的10</span><br></pre></td></tr></table></figure>


在Swift源码中是这样描述的

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">///   - defaultValue: A value to use as a default. `defaultValue` is the same</span><br><span class="line">///     type as the `Wrapped` type of `optional`.</span><br><span class="line"></span><br><span class="line">public func ?? &lt;T&gt;(optional: T?, defaultValue: @autoclosure () throws -&gt; T)</span><br><span class="line">   rethrows -&gt; T &#123;</span><br><span class="line"> 		switch optional &#123;</span><br><span class="line"> 			case .some(let value):</span><br><span class="line">   			return value</span><br><span class="line"> 			case .none:</span><br><span class="line">   			return try defaultValue()</span><br><span class="line"> 		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/pikacool1993/2019/07/22/objc-before-main/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pikacool">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="pikacool">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/objc-before-main/" itemprop="url">App启动时在main函数之前做了什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-22T16:01:06+08:00">2019-07-22</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="App-启动时在执行-main-之前做了什么"><a href="#App-启动时在执行-main-之前做了什么" class="headerlink" title="App 启动时在执行 main() 之前做了什么"></a>App 启动时在执行 main() 之前做了什么</h2><h4 id="编译的几个主要过程，生成可执行文件"><a href="#编译的几个主要过程，生成可执行文件" class="headerlink" title="编译的几个主要过程，生成可执行文件"></a>编译的几个主要过程，生成可执行文件</h4><ul>
<li>首先，你写好代码后，<code>LLVM</code> 会预处理你的代码，比如把宏嵌入到对应的位置</li>
<li>预处理完后，<code>LLVM</code> 会对代码进行词法分析和语法分析，生成 <code>AST</code> 。<code>AST</code> 是抽象语法树，结构上比代码更精简，遍历起来更快，所以使用 <code>AST</code> 能够更快速地进行静态检查，同时还能更快地生成 <code>IR</code>（中间表示）</li>
<li>最后 <code>AST</code> 会生成 <code>IR</code>，<code>IR</code> 是一种更接近机器码的语言，区别在于和平台无关，通过 <code>IR</code> 可以生成多份适合不同平台的机器码。对于 <code>iOS</code> 系统，<code>IR</code> 生成的可执行文件就是 <code>Mach-O</code></li>
</ul>
<h4 id="加载动态链接库"><a href="#加载动态链接库" class="headerlink" title="加载动态链接库"></a>加载动态链接库</h4><p>查看一个 APP 都使用了哪些动态库，包括系统自带的动态库和第三方动态库，这些动态库将会在动态链接过程中被加载</p>
<p>找到App可执行文件路径，通过 <code>otool</code> 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ otool -L TestMain</span><br></pre></td></tr></table></figure>

<p>-L 参数打印出所有 link 的 framework（去掉了版本信息如下)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TestMain:</span><br><span class="line">	/System/Library/Frameworks/Foundation.framework/Foundation</span><br><span class="line">	/usr/lib/libobjc.A.dylib</span><br><span class="line">	/usr/lib/libSystem.B.dylib</span><br><span class="line">	/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation</span><br><span class="line">	/System/Library/Frameworks/UIKit.framework/UIKit</span><br></pre></td></tr></table></figure>

<p>可以看到有两个默认添加的 <code>lib</code>: <code>libobjc</code>(<code>objc</code> 和 <code>runtime</code>), <code>libSystem</code> 中包含了很多系统级别的 <code>lib</code>, 比如我们熟知的 <code>libdispatch</code>（GCD）, <code>libsystem_c</code>（C语言库）, <code>libsystem_blocks</code>（Block）, <code>libcommonCrypto</code>（加密库，比如常用的 <code>md5</code> 函数）</p>
<p>这些 <code>lib</code> 都是 <code>dylib</code> 格式的（如 <code>Windows</code> 中的 <code>dll</code>）, 使用动态链接有如下优点：</p>
<ul>
<li>代码共用： 很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份</li>
<li>易于维护： 由于被依赖的 lib 是程序执行时才 link 的，所以这些 lib 很容易做更新，比如<code>libSystem.dylib</code> 是 <code>libSystem.B.dylib</code> 的替身，哪天想升级直接换成 <code>libSystem.C.dylib</code> 然后再替换替身就行了</li>
<li>减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多</li>
</ul>
<h4 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h4><p><code>dyld(the dynamic link editor)</code>, 动态链接器，概述 <code>dyld</code> 做了如下几件事：</p>
<ul>
<li>先执行 <code>Mach-O</code> 文件，根据 <code>Mach-O</code> 文件里 <code>undefined</code> 的符号加载对应的动态库，系统会设置一个共享缓存来解决加载的递归依赖问题</li>
<li>加载后，将 <code>undefined</code> 的符号绑定到动态库里对应的地址上</li>
<li>最后再处理 <code>+load</code> 方法，<code>main</code> 函数返回后运行 <code>static terminator</code></li>
</ul>
<h4 id="ImageLoader"><a href="#ImageLoader" class="headerlink" title="ImageLoader"></a>ImageLoader</h4><p>将文件加载进内存，且每一个文件对应一个 <code>ImageLoader</code> 实例来负责加载。</p>
<ul>
<li>在程序运行时它先将动态链接的 <code>image</code> 递归加载 （也就是上面加载的递归依赖问题）</li>
<li>再从可执行文件 <code>image</code> 递归加载所有符号</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>dyld</code> 开始将程序二进制文件(<code>Mach-O</code>)初始化</li>
<li>交由 <code>ImageLoader</code> 读取 <code>image</code>，其中包含了我们的类、方法等各种符号</li>
<li>由于 <code>runtime</code> 向 <code>dyld</code> 绑定了回调，当 <code>image</code> 加载到内存后，<code>dyld</code> 会通知 <code>runtime</code> 进行处理</li>
<li><code>runtime</code> 接手后调用 <code>map_images</code> 做解析和处理，接下来 <code>load_images</code> 中调用 <code>call_load_methods</code> 方法，遍历所有加载进来的 <code>Class</code>，按继承层级依次调用 <code>Class</code> 的 <code>+load</code> 方法和其 <code>Category</code> 的 <code>+load</code> 方法</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>Q: 重载自己 <code>Class</code> 的 <code>+load</code> 方法时需不需要调父类？<br><br>A: <code>runtime</code> 负责按继承顺序递归调用，所以不能调 <code>super</code></p>
<p>Q: 在自己 <code>Class</code> 的 <code>+load</code> 方法时能不能替换系统 <code>framework</code>（比如 <code>UIKit</code>）中的某个类的方法实现<br><br>A: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的</p>
<p>Q: 重载 <code>+load</code> 时需要手动添加 <code>@autoreleasepool</code> 么？<br><br>A: 不需要，在 <code>runtime</code> 调用 <code>+load</code> 方法前后是加了 <code>objc_autoreleasePoolPush()</code> 和 <code>objc_autoreleasePoolPop()</code> 的。</p>
<p>Q: 想让一个类的 <code>+load</code> 方法被调用是否需要在某个地方 <code>import</code> 这个文件？<br><br>A: 不需要，只要这个类的符号被编译到最后的可执行文件中，<code>+load</code> 方法就会被调用（Reveal SDK 就是利用这一点，只要引入到工程中就能工作）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">pikacool</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pikacool</span>

  

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
